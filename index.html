<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRLG Battle Sim (Airtight Puzzle Mode V2)</title>
    
    <style>
        body {
            background-color: #333; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Courier New', monospace; 
        }

        #battle-screen {
            width: 480px; 
            height: 320px; 
            border: 4px solid black;
            background-color: #98F898; 
            position: relative;
            overflow: hidden;
            image-rendering: pixelated; 
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .ui-box, .pokemon-info-box {
            position: absolute;
            background-color: #fff;
            border: 3px solid #000;
            font-size: 16px;
            box-sizing: border-box;
        }
        
        .pokemon-info-box { width: 180px; height: 60px; border-radius: 8px; padding: 4px 8px; line-height: 1; }
        #opponent-info { top: 10px; left: 10px; }
        #player-info { bottom: 120px; right: 10px; }
        .name-level { display: flex; justify-content: space-between; align-items: center; font-weight: bold; margin-bottom: 5px; }
        .hp-bar-container { display: flex; align-items: center; margin-top: 2px; }
        .hp-label { font-size: 10px; margin-right: 4px; font-weight: bold; }
        .hp-bar-outer { width: 100px; height: 8px; border: 1px solid #000; background-color: #ccc; position: relative; overflow: hidden; }
        .hp-bar-inner { height: 100%; background-color: #00ff00; transition: width 0.5s linear; } 
        .hp-text { position: absolute; right: 10px; bottom: 4px; font-size: 14px; }

        #battle-message-box {
            width: 100%; height: 110px; bottom: 0; left: 0;
            border-bottom: none; display: flex; position: absolute; z-index: 20; 
        }
        
        #message-area { width: 65%; padding: 8px; line-height: 1.2; font-weight: bold; }
        
        #action-menu {
            position: relative; width: 35%; height: 100%; border-left: 3px solid #000;
            padding: 8px; background-color: #fff; display: flex; justify-content: center; align-items: center;
        }

        #action-menu ul {
            list-style: none; padding: 0; margin: 0; display: grid; 
            grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; 
        }

        .menu-button, #action-menu li, .move-button, #back-button {
            background-color: #E0E0E0; border: 2px solid #000; padding: 8px 4px; 
            text-align: center; cursor: pointer; font-weight: bold;
            transition: background-color 0.1s; box-sizing: border-box; 
        }

        #action-menu li:hover, .menu-selected, .move-button:hover, #back-button:hover {
            background-color: #D0D0D0 !important; 
        }
        
        #move-grid-container { width: 100%; height: 100%; padding: 8px; box-sizing: border-box; background-color: #fff; }
        #move-grid { list-style: none; padding: 0; margin: 0; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 10px; width: 100%; height: 100%; }
        .sketch-selection-grid, #item-list {
             list-style: none; padding: 0; margin: 0; display: grid; 
            grid-template-columns: 1fr; grid-template-rows: repeat(auto-fill, 1fr); gap: 10px; width: 100%; height: 100%;
        }

        #info-and-back-container { width: 100%; height: 100%; display: flex; flex-direction: column; background-color: #fff; border-left: 3px solid #000; padding: 8px; box-sizing: border-box; }
        #pp-type-display { flex-grow: 1; padding: 4px; margin-bottom: 8px; border: 2px solid #000; font-size: 16px; line-height: 1.4; background-color: #fff; display: flex; justify-content: center; align-items: center; text-align: center; }
        #back-button { margin: 0; height: 40px; display: flex; align-items: center; justify-content: center; }
        
        .move-button[style*="pointer-events: none"] { background-color: #CCC !important; }

        #secondary-move-menu {
            position: absolute; bottom: 107px; left: -3px; width: 65%; height: 110px;
            background-color: #fff; border: 3px solid #000; border-bottom: none; 
            box-sizing: content-box; display: none; z-index: 15; padding: 8px;
        }

        #poc-button {
            position: absolute; width: 24px; height: 24px; background-color: #E0E0E0;
            border: 2px solid #000; border-radius: 50%; display: none; 
            justify-content: center; align-items: center; cursor: pointer; z-index: 30;
            top: -14px; left: 65%; transform: translateX(-50%); 
        }
        #poc-button:hover { background-color: #D0D0D0; }
        #poc-button::after {
            content: ''; width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-bottom: 7px solid #000; margin-bottom: 2px;
        }

        .pokemon-sprite { position: absolute; width: 64px; height: 64px; transition: transform 1s, opacity 1s, right 1s; }
        .opponent-sprite { top: 10px; right: 95px; transform: scale(2.0); transform-origin: top left; }
        .player-sprite { bottom: 60px; left: -5px; transform: scale(2.5); transform-origin: bottom left; }

        .fainted-opponent { transform: translate(0, 100px) scale(2.0) !important; opacity: 0 !important; }
        .fainted-player { transform: translate(0, 50px) scale(2.5) !important; opacity: 0 !important; }
        .slide-in { right: 95px !important; opacity: 1 !important; }
        .slide-out { right: 300px !important; opacity: 0 !important; }
    </style>
</head>
<body>

<div id="battle-screen">
    <div id="opponent-info" class="pokemon-info-box">
        <div class="name-level"><span id="opponent-name">???</span><span id="opponent-level">Lv5</span></div>
        <div id="opponent-hp-bar-container" class="hp-bar-container">
            <span class="hp-label">HP</span>
            <div class="hp-bar-outer"><div id="opponent-hp-bar" class="hp-bar-inner"></div></div>
        </div>
    </div>

    <div id="player-info" class="pokemon-info-box">
        <div class="name-level"><span id="player-name">DITTOMON</span><span id="player-level">Lv5</span></div>
        <div id="player-hp-bar-container" class="hp-bar-container">
            <span class="hp-label">HP</span>
            <div id="player-hp-bar-outer" class="hp-bar-outer"><div id="player-hp-bar" class="hp-bar-inner" style="width: 100%;"></div></div>
        </div>
        <div class="hp-text"><span id="player-current-hp">25</span> / <span id="player-max-hp">25</span></div>
        <div id="player-exp-bar"></div>
    </div>

    <img id="opponent-sprite" src="" alt="Opponent" class="pokemon-sprite opponent-sprite">
    <img id="player-sprite" src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-iii/firered-leafgreen/back/132.png" alt="Dittomon" class="pokemon-sprite player-sprite">

    <div id="secondary-move-menu" class="ui-box"></div>

    <div id="battle-message-box" class="ui-box">
        <div id="message-area"></div>
        <div id="action-menu">
            <ul> 
                <li id="menu-fight" class="menu-selected">FIGHT</li>
                <li id="menu-bag">BAG</li>
                <li id="menu-pokemon">POKÉMON</li>
                <li id="menu-run">RUN</li>
            </ul>
        </div>
        <div id="poc-button"></div>
    </div>
</div>

<script>
    // --- SPRITE CONSTANTS ---
    const SPRITE_DITTO_BACK = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-iii/firered-leafgreen/back/132.png";
    const SPRITE_SQUIRTLE_BACK = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-iii/firered-leafgreen/back/7.png";
    const SPRITE_JOLTEON_BACK = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-iii/firered-leafgreen/back/135.png";
    const SPRITE_MAROWAK_BACK = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-iii/firered-leafgreen/back/105.png";

    // --- GAME CONSTANTS (Base State) ---
    const BASE_DITTO_STATE = {
        maxHp: 25, currentHp: 25, speed: 15,
        ability: "LIMBER",
        defense: 10,
        withdrawUses: 0, // NEW: Custom tracking for Withdraw
        damageReduction: 1, // NEW: Damage reduction multiplier (1 = no reduction)
        isTransformed: false,
        sprite: SPRITE_DITTO_BACK,
        baseMoves: [
            { name: "STRUGGLE", power: 40, pp: 35, maxPp: 35, type: "NORMAL" }, 
            { name: "---", power: 0, pp: 0, maxPp: 0, type: "N/A" }, 
            { name: "---", power: 0, pp: 0, maxPp: 0, type: "N/A" }, 
            { name: "---", power: 0, pp: 0, maxPp: 0, type: "N/A" }
        ],
        baseExtraMoves: [
            { name: "TRANSFORM", power: 0, pp: 10, maxPp: 10, type: "NORMAL" },
            { name: "SKILL SWAP", power: 0, pp: 20, maxPp: 20, type: "PSYCHIC" }, 
            { name: "GUARD SWAP", power: 0, pp: 10, maxPp: 10, type: "PSYCHIC" }, 
            { name: "SKETCH", power: 0, pp: 10, maxPp: 10, type: "NORMAL" } 
        ]
    };

    // --- OPPONENT DATA QUEUE ---
    const opponentQueue = [
        { 
            name: "SQUIRTLE", 
            maxHp: 20, currentHp: 20, speed: 12,
            ability: "TORRENT", defense: 15, withdrawUses: 0, damageReduction: 1,
            spriteFront: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-iii/firered-leafgreen/7.png",
            spriteBack: SPRITE_SQUIRTLE_BACK,
            moves: [
                { name: "WATER GUN", power: 40, pp: 25, maxPp: 25, type: "WATER" }, 
                { name: "BUBBLEBEAM", power: 65, pp: 20, maxPp: 20, type: "WATER" }, 
                { name: "RAPID SPIN", power: 50, pp: 40, maxPp: 40, type: "NORMAL" }, 
                { name: "WITHDRAW", power: 0, pp: 40, maxPp: 40, type: "WATER" }
            ]
        },
        { 
            name: "JOLTEON", 
            maxHp: 65, currentHp: 65, speed: 130, // Faster!
            ability: "VOLT ABSORB", defense: 60, withdrawUses: 0, damageReduction: 1,
            spriteFront: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-iii/firered-leafgreen/135.png",
            spriteBack: SPRITE_JOLTEON_BACK,
            moves: [
                { name: "THUNDERSHOCK", power: 40, pp: 30, maxPp: 30, type: "ELECTRIC" }, 
                { name: "THUNDERBOLT", power: 95, pp: 15, maxPp: 15, type: "ELECTRIC" }, 
                { name: "THUNDER", power: 120, pp: 10, maxPp: 10, type: "ELECTRIC" }, // Thunder Buff Target
                { name: "DISCHARGE", power: 80, pp: 15, maxPp: 15, type: "ELECTRIC" }
            ]
        },
        { 
            name: "MAROWAK", 
            maxHp: 60, currentHp: 60, speed: 45,
            ability: "ROCK HEAD", defense: 110, withdrawUses: 0, damageReduction: 1,
            spriteFront: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-iii/firered-leafgreen/105.png",
            spriteBack: SPRITE_MAROWAK_BACK,
            moves: [
                { name: "BONE CLUB", power: 65, pp: 20, maxPp: 20, type: "GROUND" }, 
                { name: "EARTHQUAKE", power: 100, pp: 10, maxPp: 10, type: "GROUND" }, // OHKO Threat
                { name: "MEGA PUNCH", power: 80, pp: 20, maxPp: 20, type: "NORMAL" }, 
                { name: "BONEMERANG", power: 50, pp: 10, maxPp: 10, type: "GROUND" } 
            ]
        }
    ];

    let currentOpponentIndex = 0;
    let currentOpponent = null;

    // --- 1. GAME DATA ---
    const ditto = {
        name: "DITTOMON",
        ...BASE_DITTO_STATE,
        moves: BASE_DITTO_STATE.baseMoves.map(m => ({...m})),
        extraMoves: BASE_DITTO_STATE.baseExtraMoves.map(m => ({...m})),
        currentMoveset: BASE_DITTO_STATE.baseMoves.map(m => ({...m})) 
    };

    const inventory = [ { name: "RESET POWDER", quantity: 3 } ]; 
    
    // --- 2. ELEMENTS ---
    const battleMessageBox = document.getElementById('battle-message-box');
    const messageArea = document.getElementById('message-area');
    const pocButton = document.getElementById('poc-button');
    const secondaryMenu = document.getElementById('secondary-move-menu');
    const playerSprite = document.getElementById('player-sprite');
    const opponentSprite = document.getElementById('opponent-sprite');

    // --- 3. CORE STAT AND UI HELPERS ---
    
    // Original Gen 3 stat logic is no longer used for defense calculation.
    function calculateStat(baseStat, stage) {
        let multiplier;
        if (stage >= 0) {
            multiplier = (2 + stage) / 2;
        } else {
            multiplier = 2 / (2 + Math.abs(stage));
        }
        return Math.floor(baseStat * multiplier);
    }

    function updateHpDisplay(pokemon, elementPrefix) {
        const hpBar = document.getElementById(`${elementPrefix}-hp-bar`); 
        const currentHpText = document.getElementById(`${elementPrefix}-current-hp`);
        const percent = (pokemon.currentHp / pokemon.maxHp) * 100;
        if (hpBar) {
            hpBar.style.width = `${percent}%`;
            hpBar.style.backgroundColor = percent <= 20 ? '#ff0000' : percent <= 50 ? '#ffcc00' : '#00ff00';
        }
        if (currentHpText) {
             if (elementPrefix === 'player') document.getElementById('player-max-hp').textContent = pokemon.maxHp;
             currentHpText.textContent = pokemon.currentHp;
        }
    }

    function displayMessage(text) { messageArea.innerHTML = text.replace(/\n/g, '<br>'); }

    function toggleActionMenu(isVisible) {
        const actionMenu = document.getElementById('action-menu');
        if (actionMenu) actionMenu.style.display = isVisible ? 'flex' : 'none'; 
    }

    function removeSelectionMenu() {
         const containers = ['move-grid-container', 'info-and-back-container'];
        containers.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.remove();
        });
    }

    function loadNextOpponent() {
        if (currentOpponentIndex >= opponentQueue.length) return false;
        
        // Reset opponent state for fresh battle
        currentOpponent = opponentQueue[currentOpponentIndex];
        currentOpponent.currentHp = currentOpponent.maxHp;
        currentOpponent.withdrawUses = 0; // Reset custom state
        currentOpponent.damageReduction = 1; // Reset custom state
        currentOpponent.lastMoveUsed = null;
        
        // Update UI
        document.getElementById('opponent-name').textContent = currentOpponent.name;
        opponentSprite.src = currentOpponent.spriteFront;
        opponentSprite.classList.remove('fainted-opponent');
        opponentSprite.style.right = '95px'; // Reset position
        opponentSprite.style.opacity = '1';
        
        updateHpDisplay(currentOpponent, 'opponent');
        
        return true;
    }
    
    // --- 4. DITTO RESET LOGIC ---

    function resetDittoState() {
        // Only reset custom stats/stages/moves, KEEP HP
        ditto.ability = BASE_DITTO_STATE.ability;
        ditto.defense = BASE_DITTO_STATE.defense;
        ditto.withdrawUses = 0; // Reset custom state
        ditto.damageReduction = 1; // Reset custom state
        ditto.isTransformed = BASE_DITTO_STATE.isTransformed;
        
        ditto.moves = BASE_DITTO_STATE.baseMoves.map(m => ({...m}));
        ditto.extraMoves = BASE_DITTO_STATE.baseExtraMoves.map(m => ({...m}));
        ditto.currentMoveset = ditto.moves;
        
        if(currentOpponent) {
            // Restore base defense if it was guard swapped
            const baseOpponentDef = opponentQueue[currentOpponentIndex].defense;
            const baseDittoDef = BASE_DITTO_STATE.defense;
            currentOpponent.defense = baseOpponentDef; 
            ditto.defense = baseDittoDef;
            
            // Reset custom opponent stages
            currentOpponent.withdrawUses = 0; 
            currentOpponent.damageReduction = 1;
        }
        
        playerSprite.src = BASE_DITTO_STATE.sprite;
        playerSprite.classList.remove('fainted-player');
        playerSprite.style.opacity = 1;
        updateHpDisplay(ditto, 'player');
    }

    async function useResetPowder() {
        return new Promise(resolve => {
            removeSelectionMenu();
            messageArea.style.display = 'block';
            toggleActionMenu(false);
            displayMessage(`Trainer used the<br>RESET POWDER!`);
            setTimeout(() => {
                resetDittoState();
                displayMessage(`DITTOMON was reset!`);
                setTimeout(async () => {
                    await opponentTurn();
                    resetBattleMessageBoxToStandard();
                    resolve();
                }, 1500);
            }, 1500);
        });
    }

    // --- 5. BATTLE LOGIC ---

    function checkGameOver() {
        if (ditto.currentHp <= 0) {
            // Darken the screen
            document.body.style.backgroundColor = '#000';
            // Hide the battle screen
            const battleScreen = document.getElementById('battle-screen');
            if (battleScreen) battleScreen.style.display = 'none';
            
            // Create a Game Over message element
            const gameOverMessage = document.createElement('div');
            gameOverMessage.textContent = "Game Over. Hit Refresh to Try Again.";
            gameOverMessage.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #fff;
                font-size: 24px;
                font-family: 'Courier New', monospace;
                text-align: center;
                white-space: pre; 
            `;
            document.body.appendChild(gameOverMessage);
            return true;
        }
        return false;
    }

    function handleFaint(pokemon) {
        if (pokemon === ditto) {
            playerSprite.classList.add('fainted-player');
        } else {
            opponentSprite.classList.add('fainted-opponent');
        }
    }
    
    async function executeDamage(attacker, target, moveName, basePower, moveType) {
        return new Promise(resolve => {
            // VOLT ABSORB CHECK
            if (moveType === "ELECTRIC" && target.ability === "VOLT ABSORB") {
                const healAmount = Math.floor(target.maxHp * 0.25);
                target.currentHp = Math.min(target.maxHp, target.currentHp + healAmount);
                const elementPrefix = (target === currentOpponent) ? 'opponent' : 'player';
                updateHpDisplay(target, elementPrefix);
                displayMessage(`${target.name}'s VOLT ABSORB<br>restored HP!`);
                setTimeout(() => resolve(0), 1500); 
                return;
            }
            
            // NEW SIMPLIFIED DAMAGE CALCULATION (Tuned for OHKO Puzzle)
            // Damage = Max(1, Base Power * 0.15 + 10)
            let damage = Math.max(1, Math.floor(basePower * 0.15 + 10)); 

            // Type Effectiveness and Custom Buffs
            let effectiveness = 1;

            // Type Chart Application
            if (moveType === 'ELECTRIC' && target.name === 'MAROWAK') effectiveness = 0; // Immune
            if (moveType === 'GROUND' && target.name === 'JOLTEON') effectiveness = 2; // Super Effective
            if (moveType === 'ELECTRIC' && target.name === 'SQUIRTLE') effectiveness = 2; // Super Effective
            // 1. Bubblebeam Super Effective (against Marowak)
            if (moveType === 'WATER' && target.name === 'MAROWAK') effectiveness = 2; 

            // 2. Custom Thunder Buff (Double Damage Multiplier)
            if (moveName === 'THUNDER') {
                effectiveness *= 2; 
            }

            // Apply effectiveness
            if (effectiveness === 0) {
                 displayMessage(`It doesn't affect<br>${target.name}...`);
                 setTimeout(() => resolve(0), 1000);
                 return;
            }
            
            damage = Math.floor(damage * effectiveness);
            
            // 3. Apply custom damage reduction (from Withdraw)
            damage = Math.max(1, Math.floor(damage * target.damageReduction)); 

            target.currentHp = Math.max(0, target.currentHp - damage);
            const elementPrefix = (target === currentOpponent) ? 'opponent' : 'player';
            updateHpDisplay(target, elementPrefix);
            
            setTimeout(() => {
                if (effectiveness > 1) {
                    displayMessage(`It's super effective!`);
                } else if (effectiveness === 0) {
                     displayMessage(`It doesn't affect<br>${target.name}...`);
                }
                else {
                    displayMessage(`${target.name} took<br>damage!`);
                }
                
                setTimeout(() => resolve(damage), 1000);
            }, 500);
        });
    }

    async function applyDamage(attacker, target, damage, moveName) {
        return new Promise(async resolve => {
            const attackerMoveset = attacker === ditto ? [...ditto.currentMoveset, ...ditto.extraMoves] : currentOpponent.moves;
            const moveData = attackerMoveset.find(m => m.name === moveName);
            const basePower = moveData ? moveData.power : 0;
            const moveType = moveData ? moveData.type : "NORMAL";

            // --- Status Moves ---
            if (["TRANSFORM", "SKILL SWAP", "GUARD SWAP", "WITHDRAW", "SKETCH"].includes(moveName)) {
                displayMessage(`${attacker.name} used<br>${moveName}!`);
                toggleActionMenu(false);
                setTimeout(() => {
                    if (moveName === "TRANSFORM") {
                        playerSprite.src = currentOpponent.spriteBack;
                        ditto.isTransformed = true;
                        ditto.currentMoveset = currentOpponent.moves.map(m => ({...m}));
                        // FIX: Copy opponent's ability (Volt Absorb, Torrent, Rock Head)
                        ditto.ability = currentOpponent.ability; 
                        displayMessage(`${ditto.name} has <i>permanently</i><br>transformed into a ${currentOpponent.name}, and will remain so until Transform is used again.`); 
                    } else if (moveName === "SKILL SWAP") {
                        const temp = ditto.ability;
                        ditto.ability = currentOpponent.ability;
                        currentOpponent.ability = temp;
                        displayMessage(`${ditto.name} has <i>permanently</i><br>swapped abilities, and will remain so until Skill Swap is used again.`); 
                        const skillSwapMove = ditto.extraMoves.find(m => m.name === "SKILL SWAP");
                        if (skillSwapMove) skillSwapMove.pp--; 
                    } else if (moveName === "GUARD SWAP") {
                        const dittoDefense = ditto.defense;
                        ditto.defense = currentOpponent.defense;
                        currentOpponent.defense = dittoDefense;
                        displayMessage(`${ditto.name} has <i>permanently</i><br>swapped defenses, and will remain so until Guard Swap is used again.`); 
                        const guardSwapMove = ditto.extraMoves.find(m => m.name === "GUARD SWAP");
                        if (guardSwapMove) guardSwapMove.pp--; 
                    } else if (moveName === "WITHDRAW") {
                         // NEW CUSTOM WITHDRAW LOGIC
                         if (attacker.withdrawUses < 3) {
                            attacker.withdrawUses++;
                            // Reduce damage multiplier by 0.3, ensuring a minimum of 0.1 (90% reduction max)
                            attacker.damageReduction = Math.max(0.1, attacker.damageReduction - 0.3); 
                            const reductionPercent = Math.round((1 - attacker.damageReduction) * 100);
                            displayMessage(`${attacker.name} withdrew! Damage<br>now reduced by ${reductionPercent}%!`);
                         } else {
                            displayMessage(`But it failed! Max limit<br>reached.`);
                         }
                    } else if (moveName === "SKETCH") {
                        const isSpecialMove = ["SKETCH", "TRANSFORM", "SKILL SWAP", "GUARD SWAP", "WITHDRAW"].includes(currentOpponent.lastMoveUsed ? currentOpponent.lastMoveUsed.name : '');
                        if (!currentOpponent.lastMoveUsed || isSpecialMove) {
                            displayMessage(`But it failed!`);
                            setTimeout(() => resolve("SKETCH_FAIL"), 1500);
                            return;
                        }
                        createMoveSelectionScreen(true, currentOpponent.lastMoveUsed); 
                        resolve("SKETCH_SUCCESS_PENDING"); 
                        return;
                    }
                    setTimeout(() => resolve(moveName.replace(' ', '_')), 1500); 
                }, 1000);
                return; 
            }

            // --- Offensive Moves ---
            displayMessage(`${attacker.name} used<br>${moveName}!`);
            toggleActionMenu(false);
            
            setTimeout(async () => {
                
                // MULTI-HIT LOGIC (Bonemerang)
                if (moveName === "BONEMERANG") {
                    await executeDamage(attacker, target, moveName, basePower, moveType);
                    if (target.currentHp > 0) {
                        displayMessage("The bone hit again!");
                        await new Promise(r => setTimeout(r, 1000));
                        await executeDamage(attacker, target, moveName, basePower, moveType);
                    }
                } else {
                    // Standard Single Hit
                    await executeDamage(attacker, target, moveName, basePower, moveType);
                }

                if (target.currentHp === 0) {
                    handleFaint(target);
                    displayMessage(`${target.name} fainted!`);
                    setTimeout(() => resolve(moveName), 1500);
                } else {
                     // Recoil check (Struggle)
                    if (moveName === "STRUGGLE" && ditto === attacker && ditto.currentHp > 0) {
                        const recoil = Math.max(1, Math.floor(ditto.maxHp / 4));
                        ditto.currentHp = Math.max(0, ditto.currentHp - recoil);
                        updateHpDisplay(ditto, 'player');
                        if (ditto.currentHp === 0) {
                            handleFaint(ditto);
                            if (checkGameOver()) return; 
                        }
                        displayMessage(`${attacker.name} is hurt<br>by recoil!`);
                    }
                    setTimeout(() => resolve(moveName), 1000);
                }
            }, 1000);
        });
    }

    async function opponentTurn() {
        if (ditto.currentHp <= 0) return;

        const availableMoves = currentOpponent.moves.filter(m => m.name !== '---' && m.pp > 0);
        if (availableMoves.length === 0) return;

        const moveIndex = Math.floor(Math.random() * availableMoves.length);
        const opponentMove = availableMoves[moveIndex];
        
        opponentMove.pp--;
        currentOpponent.lastMoveUsed = {...opponentMove}; 

        await applyDamage(currentOpponent, ditto, 0, opponentMove.name);
    }

    async function handleTurn(playerMoveName) {
        let playerTurnResult = await applyDamage(ditto, currentOpponent, 0, playerMoveName); 

        if (playerTurnResult === "SKETCH_SUCCESS_PENDING") return; 
        
        // Decrement PP
        const usedMovePUM = ditto.extraMoves.find(m => m.name === playerMoveName);
        // Transform is handled here to allow multiple uses per battle
        if (usedMovePUM && usedMovePUM.pp > 0) usedMovePUM.pp--; 
        
        const usedMovePrimary = ditto.currentMoveset.find(m => m.name === playerMoveName);
        if (usedMovePrimary && usedMovePrimary.pp > 0) usedMovePrimary.pp--;

        if (ditto.currentHp > 0 && currentOpponent.currentHp > 0) {
            if (playerTurnResult !== "TRANSFORM") await opponentTurn();
        }
        
        // Check for Game Over after opponent turn or recoil
        if (checkGameOver()) return; 

        // Final state check
        if (ditto.currentHp > 0 && currentOpponent.currentHp > 0) {
            displayMessage(`What will<br>${ditto.name} do?`);
            if (playerTurnResult === "TRANSFORM") createMoveSelectionScreen(); 
            else toggleActionMenu(true);
        } else if (currentOpponent.currentHp <= 0) {
            // Opponent Defeated Logic
            currentOpponentIndex++;
            if (currentOpponentIndex < opponentQueue.length) {
                setTimeout(() => {
                     displayMessage(`${currentOpponent.name} was<br>defeated!`);
                     setTimeout(() => {
                         loadNextOpponent();
                         displayMessage(`${currentOpponent.name} sent<br>out!`);
                         setTimeout(() => {
                             displayMessage(`What will<br>${ditto.name} do?`);
                             toggleActionMenu(true);
                         }, 1500);
                     }, 2000);
                }, 1000);
            } else {
                displayMessage(`You defeated the<br>Dittomon Fangame Spec Demo! Think big!`); 
            }
        } else {
             displayMessage(`DITTOMON fainted!`);
             checkGameOver(); // This should catch faints not caught by opponent turn/recoil
        }
    }

    // --- 6. MENU SETUP (Standard) ---
    function createItemSelectionScreen() {
        removeSelectionMenu();
        const oldActionMenu = document.getElementById('action-menu');
        if (oldActionMenu) oldActionMenu.style.display = 'none';
        messageArea.style.display = 'none'; 
        pocButton.style.display = 'none';
        secondaryMenu.style.display = 'none'; 
        
        battleMessageBox.style.display = 'grid';
        battleMessageBox.style.gridTemplateColumns = '65% 35%'; 
        battleMessageBox.style.alignItems = 'stretch';
        battleMessageBox.style.padding = '0'; 
        
        let itemGridContainer = document.createElement('div');
        itemGridContainer.id = 'move-grid-container'; 
        let infoAndBackContainer = document.createElement('div');
        infoAndBackContainer.id = 'info-and-back-container';
        
        const itemList = document.createElement('ul');
        itemList.id = 'item-list';
        itemGridContainer.appendChild(itemList);
        
        const ppTypeDisplay = document.createElement('div');
        ppTypeDisplay.id = 'pp-type-display';
        ppTypeDisplay.innerHTML = `<div style="font-size: 16px;">Items are currently<br>only usable on DITTOMON.</div>`;

        const backButton = document.createElement('div');
        backButton.id = 'back-button';
        backButton.textContent = 'BACK';
        backButton.className = 'menu-button'; 
        backButton.addEventListener('click', resetBattleMessageBoxToStandard);

        infoAndBackContainer.appendChild(ppTypeDisplay);
        infoAndBackContainer.appendChild(backButton);
        battleMessageBox.appendChild(itemGridContainer);
        battleMessageBox.appendChild(infoAndBackContainer);

        inventory.forEach(item => {
            if (item.quantity > 0) {
                const itemButton = document.createElement('li');
                itemButton.textContent = `${item.name} x${item.quantity}`;
                itemButton.className = `menu-button item-button`;
                itemButton.dataset.itemName = item.name;
                itemButton.addEventListener('click', async () => {
                    inventory[0].quantity--; 
                    await useResetPowder();
                });
                itemList.appendChild(itemButton);
            }
        });
        
        if (inventory.filter(i => i.quantity > 0).length === 0) {
            const emptyMessage = document.createElement('li');
            emptyMessage.textContent = "NO ITEMS";
            emptyMessage.style.textAlign = 'center';
            itemList.appendChild(emptyMessage);
        }
    }

    function createMoveSelectionScreen(isSketchSelection = false, sketchedMove = null) {
        const oldActionMenu = document.getElementById('action-menu');
        if (oldActionMenu) oldActionMenu.style.display = 'none';
        messageArea.style.display = 'none'; 
        pocButton.style.display = isSketchSelection ? 'none' : 'flex'; 
        secondaryMenu.style.display = 'none'; 
        removeSelectionMenu(); 
        
        battleMessageBox.style.display = 'grid';
        battleMessageBox.style.gridTemplateColumns = '65% 35%'; 
        battleMessageBox.style.alignItems = 'stretch';
        battleMessageBox.style.padding = '0'; 
        
        let moveGridContainer = document.createElement('div');
        moveGridContainer.id = 'move-grid-container';
        let infoAndBackContainer = document.createElement('div');
        infoAndBackContainer.id = 'info-and-back-container';
        
        const ppTypeDisplay = document.createElement('div');
        ppTypeDisplay.id = 'pp-type-display';
        const backButton = document.createElement('div');
        backButton.id = 'back-button';
        backButton.textContent = 'BACK';
        backButton.className = 'menu-button'; 
        infoAndBackContainer.appendChild(ppTypeDisplay);
        infoAndBackContainer.appendChild(backButton);
        
        battleMessageBox.appendChild(moveGridContainer);
        battleMessageBox.appendChild(infoAndBackContainer);

        backButton.addEventListener('click', resetBattleMessageBoxToStandard);

        moveGridContainer.innerHTML = ''; 
        let moveGrid;

        if (isSketchSelection) {
            moveGrid = document.createElement('ul');
            moveGrid.className = 'sketch-selection-grid'; 
            moveGridContainer.appendChild(moveGrid);
            messageArea.style.display = 'block'; 
            displayMessage(`Which move will you<br>replace?`); 
            populateMoveGrid(moveGrid, ditto.currentMoveset, 'sketch-target');
            addSketchSelectionListeners(moveGrid, sketchedMove);
            infoAndBackContainer.style.display = 'none';
        } else {
            moveGrid = document.createElement('ul');
            moveGrid.id = 'move-grid';
            moveGridContainer.appendChild(moveGrid);
            infoAndBackContainer.style.display = 'flex';
            populateMoveGrid(moveGrid, ditto.currentMoveset);
            addMoveEventListeners(moveGrid, ditto.currentMoveset);
            setupSecondaryMenu();
            updateMoveInfo(ditto.currentMoveset[0]);
        }
    }

    function setupSecondaryMenu() {
        secondaryMenu.innerHTML = ''; 
        const secGrid = document.createElement('ul');
        secGrid.id = 'secondary-move-grid';
        secGrid.style.cssText = `list-style: none; padding: 0; margin: 0; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 10px; width: 100%; height: 100%;`;
        populateMoveGrid(secGrid, ditto.extraMoves);
        secondaryMenu.appendChild(secGrid);
        addMoveEventListeners(secGrid, ditto.extraMoves);
    }

    function populateMoveGrid(gridElement, movesArray, extraClass = '') {
        gridElement.innerHTML = ''; 
        movesArray.forEach((move, index) => {
            const moveButton = document.createElement('li');
            moveButton.textContent = move.name;
            moveButton.className = `move-button ${extraClass}`;
            moveButton.dataset.moveIndex = index;
            if (gridElement.id === 'secondary-move-grid' && (move.name === '---' || move.pp <= 0)) {
                 moveButton.style.pointerEvents = 'none';
            }
            gridElement.appendChild(moveButton);
        });
    }

    function updateMoveInfo(moveData) {
        const ppTypeDisplay = document.getElementById('pp-type-display');
        if (!ppTypeDisplay) return;
        let { name, pp, maxPp, type } = moveData;
        if (name === 'SKETCH') { pp = maxPp; } 
        if (name === '---') { pp = '—'; maxPp = '—'; type = 'N/A'; }
        ppTypeDisplay.innerHTML = `<div style="font-size: 16px; font-weight: bold;">PP ${pp}/${maxPp}<br>TYPE/${type}</div>`;
    }

    function addMoveEventListeners(gridElement, sourceArray) {
        const moveButtons = gridElement.querySelectorAll('.move-button');
        moveButtons.forEach(button => {
            button.addEventListener('mouseover', () => {
                document.querySelectorAll('.move-button').forEach(b => b.classList.remove('menu-selected'));
                button.classList.add('menu-selected');
                const moveData = sourceArray[button.dataset.moveIndex];
                updateMoveInfo(moveData);
            });
            if (button.textContent !== '---') {
                button.addEventListener('click', async () => {
                    resetBattleMessageBoxToStandard();
                    await handleTurn(button.textContent);
                });
            }
        });
    }

    function addSketchSelectionListeners(gridElement, sketchedMove) {
        const moveButtons = gridElement.querySelectorAll('.sketch-target'); 
        moveButtons.forEach(button => {
            button.addEventListener('mouseover', () => {
                document.querySelectorAll('.sketch-target').forEach(b => b.classList.remove('menu-selected'));
                button.classList.add('menu-selected');
                updateMoveInfo(sketchedMove); 
            });
            button.addEventListener('click', async () => {
                const moveIndex = parseInt(button.dataset.moveIndex);
                const oldMoveName = ditto.currentMoveset[moveIndex].name;
                ditto.currentMoveset[moveIndex] = {...sketchedMove}; 
                removeSelectionMenu();
                displayMessage(`${ditto.name} forgot ${oldMoveName}<br>and learned ${sketchedMove.name}!`);
                setTimeout(async () => {
                    if (ditto.currentHp > 0 && currentOpponent.currentHp > 0) {
                        await opponentTurn();
                        resetBattleMessageBoxToStandard();
                    } else {
                        resetBattleMessageBoxToStandard();
                    }
                }, 1500);
            });
        });
    }

    function resetBattleMessageBoxToStandard() {
        removeSelectionMenu();
        secondaryMenu.style.display = 'none';
        pocButton.style.display = 'none'; 
        battleMessageBox.style.display = 'flex';
        messageArea.style.display = 'block';
        messageArea.style.width = '65%';
        displayMessage(`What will<br>${ditto.name} do?`);
        toggleActionMenu(true);
        setupMainMenuEventListeners();
    }
    
    function setupMainMenuEventListeners() {
        const fightButton = document.getElementById('menu-fight');
        if (fightButton) {
            const newBtn = fightButton.cloneNode(true);
            fightButton.parentNode.replaceChild(newBtn, fightButton);
            newBtn.addEventListener('click', () => {
                if (ditto.currentHp > 0) {
                    messageArea.style.display = 'block';
                    displayMessage(`What will<br>${ditto.name} do?`); 
                    createMoveSelectionScreen(false);
                }
            });
        }
        
        const bagButton = document.getElementById('menu-bag');
        if (bagButton) {
            const newBtn = bagButton.cloneNode(true);
            bagButton.parentNode.replaceChild(newBtn, bagButton);
            newBtn.addEventListener('click', () => {
                if (ditto.currentHp > 0) {
                    displayMessage(`Which item will<br>you use?`);
                    createItemSelectionScreen();
                }
            });
        }
        
        const actionMenu = document.getElementById('action-menu');
        if (actionMenu) {
            actionMenu.querySelectorAll('li').forEach(item => {
                item.addEventListener('mouseover', () => { 
                    actionMenu.querySelectorAll('li').forEach(i => i.classList.remove('menu-selected')); 
                    item.classList.add('menu-selected'); 
                });
            });
        }
    }
    
    pocButton.addEventListener('click', () => {
        const isVisible = secondaryMenu.style.display === 'block';
        secondaryMenu.style.display = isVisible ? 'none' : 'block';
    });

    // --- INIT ---
    document.addEventListener('DOMContentLoaded', () => {
        updateHpDisplay(ditto, 'player');
        
        // Initial Opponent Load
        loadNextOpponent();
        
        setTimeout(() => {
            displayMessage(`Wild ${currentOpponent.name}<br>appeared!`); 
            setTimeout(() => {
                displayMessage(`What will<br>${ditto.name} do?`);
                setupMainMenuEventListeners(); 
                toggleActionMenu(true);
            }, 1500);
        }, 500);
    });
</script>

</body>
</html>